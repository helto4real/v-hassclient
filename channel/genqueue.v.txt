module channel

struct FastQueue<T> {
mut:
	read_index		int 		
	write_index		int 	
	q        []&T
pub:
	max_size int
pub mut:
	size     int
}

fn (mut q FastQueue) push<T>(mut item T) ?bool {
	if q.full() {
		return error("queue is full")
	}

	q.q[q.write_index] = item

	q.write_index++
	q.size++

	if q.write_index == q.max_size
	{
		q.write_index = 0
	}
	return true
}

// pop reads on item from queue
fn (mut q FastQueue) pop<T>() ?&T {

	if q.empty() {return error('queue is empty')}

	item := q.q[q.read_index]

	q.read_index++
	q.size--

	if q.read_index == q.max_size
	{
		q.read_index = 0
	}
	return item
}

[inline]
// full returns true if queue is full
fn (q FastQueue) full<T>() bool {
	return q.size == q.max_size
}

[inline]
// full returns true if queue is full
fn (q FastQueue) empty<T>() bool {
	return q.size == 0
}

// new_queue instance a new queue with static max_size
fn new_fast_queue<T>(max_size int) ?&FastQueue<T> {
	if max_size <=0 {return error("max_size have to be greater than zero")}

	q:= &FastQueue {
		q: []&T{len: max_size}
		max_size: max_size
	}
	return q
}
